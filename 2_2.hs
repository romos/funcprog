{--
Задача 2-2*	
Одеров Роман, 545 гр.
--}

c n = f 1 n []

{-
	f s n xs - функция, считающая количество разложений числа n 
				на взаимнопростые слагаемые
	s - элемент, который претендует на то, чтобы быть очередным в разложении
	n - сколько нам осталось разложить (без учета s).
	xs- набор предыдущих слагаемых в разложении.
-}

f s n xs = if s*2 < n 		
				--пока слагаемое меньше половины остатка,есть шанс на вз.-простое
				--разложение со след.слагаемым (s+1) :
				-- 1: начать со след.слагаемого или
				-- 2: продолжить по возрастанию дальше
			then (f (s+1) n xs) + (f (s+1) (n-s) (s:xs))

			else --если слагаемое стало >= половине остатка, то верно, что разложение не будет
				 --упорядоченным по возрастанию (что противоречит перебору). Т.о. надо 
				 --добавить в разложение весь остаток, как единственно возможный вариант
				if primeList (n:xs) then 1 else 0 -- и проверить на простоту.


{-
	Проверка взаимной простоты элементов списка:
		Сначала проверить "голову"" с "остатком", а потом проверить остаток рекурсивно.
	Проверка "головы"" с "остатком":
		Сначала проверить со вторым элементом, а потом с оставшимися рекурсивно.
-}
primeList [] = True
primeList (l:ls) = primeList' l ls && primeList ls
primeList' _ [] = True
primeList' l (x:xs) = primes l x && primeList' l xs

primes a b = if (gcd a b == 1) then True else False


{- Не думал, что есть стандартный 'gcd' :-)

-- Функция, находящая НОД двух чисел.
-- НОД = 1 => TRUE (взаимно просты)
my_gcd 0 a = a
my_gcd a 0 = a
my_gcd a b = if (a < b) then my_gcd b a
			else
				if (mod a b == 0) then b
				else
					my_gcd b (mod a b)
-}