{--
    Task 1
    Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).
    Пример вызова:

    f = repeatFunc sin 3

    должно определить f x = sin (sin (sin x))
    и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.
--}

--repeatFunc f n = foldr (\_ f' -> f.f') f [1..(n-1)]

{--
    Task 2
    Определите функцию repeatFunc с двумя параметрами f и n, которая возвращает функцию f.f. ... .f (т.е. композицию функции с самой собой n раз).
    Пример вызова:

    f = repeatFunc sin 3

    должно определить f x = sin (sin (sin x))
    и после этого можно написать, например, f 2 и получить sin (sin (sin 2))- это примерно 0.7097.

    Дополнительное условие:
    - В этой задаче нельзя определять свои рекурсивные функции. Можно использовать стандартные функции и можно, если хотите, определять нерекурсивные функции.

    Замечание:
    - Если вы решите эту задачу, то можете выложить ее решение и как решение для задачи 11.1, оно будет засчитано.
--}
repeatFunc f n = foldr (\_ f' -> f.f') f [1..(n-1)]

{--
    Task 3
    Перечислить все способы выдать данную сумму n монетами по 2, 3 и 5 коп. Результат должен быть списком списков целых чисел, каждый внутренний список - это список из трех элементов [k,l,m], где k - двухкопеечных монет, l - количество трехкопеечных, m - количество пятикопеечных монет.

    Пример вызова:
    coins 10

    Должно получиться:
    [[5,0,0],[2,2,0],[0,0,2],[1,1,1]]
    (порядок троек в ответе может быть и другим).

    Замечание:
    - Вообще это упражнение на list comprehension. Но, если хотите, вы можете решить задачу и без list comprehension, как хотите.
--}
coins n = [[x,y,z] | x <- [0..(n `div` 2)], y <- [0..(n `div` 3)], z <- [0..(n `div` 5)], 2*x + 3*y + 5*z == n]

{--
    Task 4
    Пусть мы хотим описывать в программе на Хаскеле электрические схемы. Мы считаем, что электрическая схема - это:
    - или сопротивление, тогда известно его величина в омах
    - или две схемы, соединенных параллельно
    - или две схемы, соединенных последовательно
    (На самом деле есть схемы, которые таким способом не описать, ну и ладно..)

    1. Опишите тип (data) Scheme, который позволяет описывать такие схемы.
    2. Опишите функцию totalResistance, у которой один параметр - схема, и которая возвращает значение общего сопротивления для этой схемы.

    Например, для двух сопротивлений 4 Ом, соединенных последовательно, функция должна возвращать 8, а для двух сопротивлений 4 Ом, соединенных параллельно, функция должна возвращать 2.

    Замечания:
    - Для этой задачи тестов не будет, потому что я не знаю, как вы решите представлять схемы. Но я проверю задачи вручную.
    - Если вы забыли, как считать общее сопротивление схемы - напишите, я подскажу :)
--}
data Scheme a = Resistance a | Parallel (Scheme a) (Scheme a) | Sequential (Scheme a) (Scheme a)
totalResistance (Sequential part1 part2) = totalResistance part1 + totalResistance part2
totalResistance (Parallel part1 part2) =
    let
      r1 = totalResistance part1
      r2 = totalResistance part2
    in r1*r2/(r1 + r2)
totalResistance (Resistance r) = r

--totalResistance (Parallel (Sequential (Resistance 4) (Resistance 4)) (Sequential (Resistance 4) (Resistance 4)))

