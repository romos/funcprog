{--
    Task 1
    *Доп задача, до 7.10*
    У функции два параметра - целые числа a и b. Точно известно, что они взаимно простые. Функция должна вернуть такую пару целых чисел x и y, что a*x + b*y == 1. (Таких пар, конечно, бесконечно много, можно вернуть любую).

    Пример вызова:
    euclid 3 5
    Должно получиться (2, -1), потому что 3*2+5*(-1) == 1

    Замечания:
    - Если a и b не взаимно простые, то функция может делать что угодно (например, аварийно завершаться, или выдавать любой ответ).
    - Желательно, чтобы функция быстро работала для _очень_ больших чисел, например, для 2^100 и 3^100. Но, если не получится, напишите любое решение, не обязательно очень эффективное (например, которое ищет решения перебором).
    - Подсказка: идея, которую можно использовать для эффективного решения, была впервые опубликована примерно в 300 г. до н.э. :)
--}
euclid a b
  | a == 0 = (0, 1)
  | otherwise =
      let
        (x1, y1) = euclid (mod b a) a
      in (y1 - (div b a) * x1, x1)

{--
    Task 2
    *Доп задача, до 7.10*
    Описать функцию dioph, параметры которой - два списка из 4 целых чисел [a, b, c, d] и [k, l, m, n], и которая возвращает список из 3 целых чисел [x, y, z] таких, что:

    a*x+b*y+c*z=d
    k*x+l*y+m*z=n

    Замечания: 
    - Что делать, если таких чисел нет - на ваше усмотрение. Можно выдать ошибку, можно вернуть (0, 0, 0) и т.д. В тестах таких случаев не будет.
    - Числа в тестах могут быть достаточно большими для того, чтобы эту задачу не было смысла решать простым перебором, надо придумать что-то более эффективное.
    - Эта задача не то чтобы очень сложная, но решение, которое я знаю - довольно громоздкое, в нем надо рассматривать разные вырожденные случаи и т.д.. Т.е. это для тех, кому интересно решить что-то немного посложнее.
--}

-- separate files
