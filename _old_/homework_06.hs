{--
    Task 1
    Опишите функцию isosc (от слова isosceles - равнобедренный), у которой три параметра - пары целых чисел, и которая возвращает True, если соответствующие точки на плоскости задают равнобедренный треугольник, а иначе False.

    Примеры вызова:
    isosc (0, 2) (2, 0) (2,2)
    - результат должен быть равен True
    isosc (-3, 2) (2, 0) (2,2)
    - результат должен быть равен False
--}
isosc x y z = 
  let
    a = len x y
    b = len y z
    c = len z x
  in a == b || b == c || c == a
len (x1, y1) (x2, y2) = sqrt ((x1 - x2)^2 + (y1 - y2)^2)

{--
    Task 2
    Описать функцию cubeTable, которая для данного n возвращает список пар чисел (i, i в кубе) для всех i от 1 до n.

    Дополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но, видимо, особо не нужно), определять свои не рекурсивные функции.

    Пример вызова:
    cubeTable 4
    Должно получиться [(1, 1), (2, 8), (3, 27), (4, 64)]
--}
cubeTable n = map (\i -> (i, i^3)) [1..n]

{--
    Task 3
    Определить функцию minsum, такую же, как в задаче 3.2. Т.е. функция должна искать минимум суммы двух стоящих рядом элементов в данном списке.

    Дополнительное условие: _Нельзя_ определять свои рекурсивные функции. Т.е. можно (и нужно) использовать стандартные функции. Можно (но не очень нужно), определать свои не рекурсивные функции.

    Пример вызова:
    minsum [1,8,3,2,7] 
    Ответ должен быть равен 5 (3+2).

--}
minsum (x:xs) = 
    let
      (_:ys) = foldl (\(z:zs) t -> (t:(t + z):zs)) [x] xs
    in minimum ys

{--
    Task 4
    Описать функцию height, хоторая ищет высоту данного дерева. 

    Замечание: В задаче вы сначала должны описать data для дерева. И его надо описать точно так же, как на занятии. Извините за ограничение вашей творческой свободы, но это, понятно, ограничение системы тестирования..

    Примеры вызова:
    height (Node 1 Empty Empty)
    Ответ должен быть 0
    height (Node 1 (Node 1 Empty Empty) Empty)
    Ответ должен быть 1
--}
data Tree = Empty | Node Integer Tree Tree
height Empty = -1
height (Node _ l r) = max (height l) (height r) + 1

{--
    Task 5
    * Описать функцию minHeight, хоторая для данного дерева возвращает минимум расстояния от корня до какого-нибудь листа. 

    Замечание: В этой задаче _обязательно_ должна быть реализована оптимизация, о которой мы говорили на занятии.

    Напоминание: Лист - это вершина, у которой и левое и правое поддеревья пустые.

    Примеры вызова:
    minHeight(Node 1 Empty Empty)
    Ответ должен быть 0
    minHeight (Node 1 (Node 2 (Node 3 Empty Empty) Empty) (Node 4 Empty Empty))
    Ответ должен быть 1 (расстояние от корня до вершины 4)

    minHeight (Node 1 Empty (Node 1 (Node 1 Empty (Node 1 Empty Empty)) (Node 1 Empty (Node 1 Empty Empty))))
    3
--}

--data Tree = Empty | Node Integer Tree Tree
minHeight t = minHeight' t (1/0) 0
minHeight' Empty minH h = minH
minHeight' (Node _ Empty Empty) _ h = h
minHeight' (Node _ l r) minH h
  | minH <= h = minH
  | otherwise =
      let
        minH1 = min minH (minHeight' l minH (h + 1))
      in minHeight' r minH1 (h + 1)

{--
    Task 6
    "Рамочка"

    Пусть мы используем списки списков, чтобы представлять в Хаскеле двумерные массивы. Описать функцию frame n, которая возвращает список списков, соответствующий массиву n на n, в котором по краям (в первом и последнем столбце и в первой и последней строке) все элементы равны 1, а все остальные элементы равны 0.

    Пример вызова:
    frame 4
    Должно получиться:
    [[1, 1, 1, 1],
    [1, 0, 0, 1],
    [1, 0, 0, 1],
    [1, 1, 1, 1]]
--}
frame n =
  let
    generateline m isBound = map (\t -> if isBound || t == 1 || t == n then 1 else 0) [1..n]
    generateLine' m
      | m == 1 || m == n = generateline m True
      | otherwise = generateline m False
  in map generateLine' [1..n]

{--
    Task 7
    Опишите две функции, countOdd и countOdd1, которые для данного списка вычисляют количество нечетных чисел в этом списке. (Т.е. надо написать две версии одной функции).

    Дополнительные условия:
    - В функции countOdd можно использовать _только_ стандартную функцию foldr. Можно (но особо не нужно) задавать свои нерекурсивные функции. Можно, 
    конечно, использовать лямбда-выражения.

    - В функции countOdd1 можно использовать любые стандартные функции, и тоже, если надо, можно использовать свои нерекурсивные функции и лямбда-выражения. Но _нельзя_ определять свои рекурсивные функции.

    Пример вызова:
    countOdd [2, 3, 4, 8, 5, 33, 9]
    Ответ должен быть равен 4
--}
countOdd xs = foldr (\x res -> if mod x 2 == 1 then res + 1 else res) 0 xs
countOdd1 xs = sum (map (\x -> mod x 2) xs)
{--
    Task 8
    Опишите функцию myfoldl, которая делает точно то же, что и стандартная функция foldl (т.е. сворачивает все элементы слева направо).

    Пример вызова:
    myfoldl (+) 0 [1,2,3]
    Функция должна вычислить ((0+1)+2)+3, причем вычисления должны происходить именно в таком порядке.
--}
myfoldl _ e [] = e
myfoldl f e (x:xs) = myfoldl f (f e x) xs
