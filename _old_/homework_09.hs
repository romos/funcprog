{--
    Task 1
    Описать функцию powerset, которая по списку порождает список из всех его подсписков.

    Пример вызова:
    powerset [1, 2, 3]
    Результат д.б. равен [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]. (Порядок элементов в ответе м.б. и другим, как вам удобнее).
--}
powerset [] = [[]]
powerset (x:xs) = 
    let
      ys = powerset xs
      ts = map (\qs -> (x:qs)) ys
    in foldr (:) ts ys

{--
    Task 2
    Используя _только_ функцию foldr и лямбда выражения опишите функцию myreverse, возвращающую элементы списка в обратном порядке.
    Пример вызова:
    myreverse [1, 2, 3]
    Результат д.б. равен [3, 2, 1].

    Дополнительные условия:
    - В этой задаче можно использовать только функцию foldr и лямбда выражения. Можно (но особо не нужно) определять свои не рекурсивные функции.
    - Функция должна работать за линейное время. Технически это означает, что нельзя использовать операцию ++ [x] или каким-то другим способом приписывать очередной элемент к концу списка на каждом шаге работы foldr. 
    - (ДОБАВЛЕНИЕ) Чтобы задача была немного еще посложнее, давайте пусть будет еще дополнительно условие - нельзя использовать пары (tuples). (И соответственно нельзя каким-то образом их имитировать, с помощью списков из двух элементов или data и т.д.)

    Замечания:
    - Обратите внимание, надо использовать именно foldr, а не foldl. С foldl то все просто..
    - Эта задача не очень простая. Точнее, решение у нее довольно простое и короткое, но додуматься до него, м.б. и не так просто. Если не получиться, не расстраивайтесь..
--}

--myreverse xs = map (\(z:zs) -> z) (foldr (\t ((y:ys):yss) -> if ys /= [] then (ys:(y:ys):yss) else ((y:ys):yss)) [xs] xs)

myreverse1 xs = 
    let
      (a:as) = foldr (\t ((y:ys):yss) -> (ys:(y:ys):yss)) [xs] xs
    in map (\(z:zs) -> z) as

myreverse xs = foldr (\t f ys -> f (t:ys)) id xs []
