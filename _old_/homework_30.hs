{--
    Task 1
    а. Описать тип Expr, позволяющий задавать выражения с несколькими переменными. Тип должен позволять задать, например, такое выражение:

    Add (Var "x") (Mult (Var "y") (N 3))

    (И это должно соответствовать x+y*3 в обычном языке.) 

    б. Описать функцию eval для таких выражений. Ее второй параметр должен быть списком пар (имя переменной, значение переменной).

    Пример вызова:

    eval (Add (Var "x") (Mult (Var "y") (N 3))) [("x", 5), ("y", 8)]

    Результат должен быть равен 29

    Замечание:
    - Не очень понятно что делать, если для какой-то переменной значение не задано. Вы можете задать любое поведение в этом случае, или вообще не рассматривать такой случай. В тестах такого не будет.
--}
{--
data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr

getValue ((v, val):vars) x = if x == v then val else getValue vars x
getValue [] _ = 0

eval (Var x) vars = getValue vars x
eval (N n) _ = n
eval (Add s1 s2) n = eval s1 n + eval s2 n
eval (Mult m1 m2) n = eval m1 n * eval m2 n
--}

{--
    Task 2
    а. К типу Expr из задачи 30-1, добавить еще возможность описывать что-то похожее на let выражения. Вот пример такого выражения

    Add (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1)

    (И это должно соответствовать (let x = 10 in x*y) + 1 в обычном языке.) 

    б. Дописать функцию eval из задачи 30-1, чтобы она вычисляла let выражения. 

    Пример вызова:

    eval (Add (Let "x" 10 (Mult (Var "x") (Var "y"))) (N 1)) [("y", 2)]

    Результат должен быть равен 21
--}
data Expr = Var String | N Integer | Add Expr Expr | Mult Expr Expr | Let String Integer Expr

getValue ((v, val):vars) x = if x == v then val else getValue vars x
getValue [] _ = 0

eval (Var x) vars = getValue vars x
eval (N n) _ = n
eval (Add s1 s2) n = eval s1 n + eval s2 n
eval (Mult m1 m2) n = eval m1 n * eval m2 n
eval (Let x val e) vars = eval e ((x, val) : vars)
{--
    Task 3
    Опишите функцию sum_cps которая ищет сумму элементов данного списка, используя continuation-passing style.

    Примеры вызова:

    sum_cps [1,2,3] id 
    Результат дб равен 6

    sum_cps [1,2,3] (^2)
    Результат дб равен (1+2+3)^2=36

    Дополнительные условия:
    - Нельзя определять никакие новые функции, кроме sum_cps.
    - Нельзя использовать никакие стандартные функции для работы со списками.
    - Определение sum_cps должно быть tail recursive
    (Эти все условия следуют из того что функция должна использовать constinuation passing style, я их выписал просто для тех, кто мб не был на занятии).
--}
sum_cps [] f = f 0
sum_cps (x:xs) f = f (sum_cps xs (+x))

{--
    Task 4
    *Простое упражнение на использование >>= и do нотации*

    Опишите две функции triangle1 и triangle2. Обе должны для данного n возвращать список:

    [1, 
    1, 2, 
    1, 2, 3,
    ...
    1, 2, 3, ..., n]

    Дополнительные условия:
    - triangle1 надо написать с помощью оператора >>= и функции return
    - triangle2 надо написать с помощью do нотации

    Примеры вызова:

    triangle1 3
    triangle2 3

    В обоих случаях должно получиться:
    [1,1,2,1,2,3]
--}
concat1 xss = xss >>= id

triangle1 n = concat1 ([1..n] >>= \i -> return [1..i])
triangle2 n =
    concat1 (do i <- [1..n]
                return [1..i])

{--
    Task 5
    Пусть функция find описана так:

    find cond [] = []
    find cond (x:xs) = if cond x then [x] else find cond xs

    (Т.е. для того, чтобы сообщить о том, что ничего не найдено, мы используем пустой список).

    С помощью этого варианта find описать функцию f, которая делает вот что:
    В данном списке f ищет:
    - первое число, меньшее 5
    - первое число, большее 10
    - первое число, не равное 7
    и возвращает:
    - если хотя бы один поиск был неудачным, возвращает []
    - если все числа найдены, возвращает список из одного элемента - их суммы.

    Примеры вызова:

    f [7, 6, 4, 3, 20, 15, 9] 
    Результат должен быть равен [30], потому что первое < 5 - это 4, первое > 10 - это 20 и первое /= 7 - это 6 и их сумма равна 30

    f [7, 6, 4, 3, 9]
    Результат должен быть равен [], потому что один из трех поисков ничего не находит.

    Замечания: 
    - Это просто упражнение, на то, как удобнее работать с несколькими вызовами функции, которая может завершиться неудачно. (К сожалению, забыл обсудить ее на занятии).
    - Задачу можно решить очень коротко, в одну строку. 
    - Если коротко не получиться, вы можете присылать любое решение.
--}
{--
find cond [] = []
find cond (x:xs) = if cond x then [x] else find cond xs

f xs = let res = concat [find (<5) xs, find (>10) xs, find (/=7) xs] in if length res == 3 then return (sum res) else []
--}
{--
    Task 6
    Написать функцию toInt, которая по данному числу Черча возвращает обычное число.

    Пример вызова:

    toInt (\f x -> f (f (f x)))

    Результат должен быть равен 3.

    Замечание: 
    - Задача очень простая, пишется в одну строку.
    - В условии еще должна быть, конечно, обратная наклонная черта, но, к сожалению система тестирования по прежнему не умеет ее выводить (( 

--}
toInt churchNum = churchNum (+1) 0

{--
    Task 7
    Написать функцию inc, которая прибавляет 1 к числу Черча.

    Например, вызов inc (f x -> f (f (f x))) должен вернуть f x -> f (f (f (f x))). 

    Пример вызова:
    toInt (inc (\f x -> f (f (f x))))
    Результат д.б. равен 4.

    Замечание: 
    - Это тоже очень простая задача.
    - И тут тоже в условии должна быть обратная наклонная черта, но система тестирования не умеет ее выводить..
--}
--toInt churchNum = churchNum (+1) 0
inc churchNum = \f x -> f (churchNum f x)

{--
    Task 8
    Пусть мы описали функцию find вот так:

    find cond (x:xs) = if cond x then (x, xs) else find cond xs

    (В этом задании мы не думаем о том, что будет, если мы ничего не найдем. Тут мы считаем, что всегда все находим).

    Т.е. у нас есть функции, которые возвращают пару из какого-то значения и хвоста списка. Мы бы хотели написать оператор, немного похожий на оператор композиции (.), Но только чтобы он сначала вызывал одну функцию, а потом вторую функцию вызывал для хвоста, полученного в результате первого вызова.

    Задача: Определить такой оператор, назовем его >>>, чтобы можно было писать так:

    f = find (>3) >>> find (>3) 
    -- f - это функция, которая ищет в списке второй элемент, больший 3.
    f [1, 3, 5, 2, 20, 25, 2]
    -- Должно получиться (20, [25, 2])
--}
find cond (x:xs) = if cond x then (x, xs) else find cond xs

(>>>) f1 f2 xs = let (y, ys) = f1 xs in f2 ys

